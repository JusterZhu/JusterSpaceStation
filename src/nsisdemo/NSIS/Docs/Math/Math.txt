Math::Script NSIS插件帮助文档

类C语言风格的脚本（至少有操作符）。
提示1：插件区分字母大小写。
提示2：插件几乎不检查错误。因此，在运行之前，您应该仔细检查您的脚本两次 :)

新的使用方法：运行MathTest.Exe，自己尝试一下。花费几分钟后，您应该能够自己编写脚本。
要将其包含到NSIS脚本中，只需插入以下内容：
Math::Script "YourScript1"
Math::Script "YourScript2"
Math::Script "YourScriptFinal"

如何使用？简单：
Strcpy $0 "Brainsucker"
Math::Script "a = 'Math'; B = 'Script'; r0 += ' wants to use ' + a + '::' + b +'!'"
DetailPrint "$0"
这个字符串将用一些东西填充r0。

以下是一些其他示例：
10!（阶乘，r0将包含“10！= 362880”）：
r0 ='10！= '+ (123456789)
相同的结果：
a = b = 1; #{++a <= 10, b = ba}; r0 = (a-1) + '! = ' + b
一些浮点数：
Strcpy $R0 "1e1"
Math::Script "pi = 3.14159; R1 = 2pi*R0; r0 = 'Length of circle with radius ' + R0 + ' is equal to ' + R1 + '.'"
Detailprint "$0"

好的。变量。
NSIS：r0-r9 -> $0-$9. R0-R9 -> $R0-$R9。
还有CL（$CMDLINE）、ID（$INSTDIR）、OD（$OUTDIR）、LG（$LANG）、ED（$EXEDIR）。
用户可定义的：以字符开头，长达28个字母的名称。

堆栈。支持两个堆栈：NSIS堆栈和插件自己的堆栈。我看不出使用插件堆栈的理由，但如果您使用它，请记住-插件在函数执行之前将在该堆栈中存储用于函数的变量，并在执行后进行恢复。我更不建议您使用NSIS堆栈。您应该仅将其用于输入/输出。
如何使用？它的样式与变量相似。插件堆栈与S变量相关联，NSIS堆栈与NS变量相关联。要将其推送到堆栈中，请执行“S=0”或“NS=0”，要从堆栈中弹出，请执行“a=S”或“b=NS”。还支持组合操作：“S += 1.5”将递增堆栈顶部的值1.5。

支持的数据类型：整数（实际上是 __int64）、浮点数（实际上是双精度浮点数）、字符串。
整数：只有数字，可能带有符号。
浮点数：-123.456、123.456e-78、123e-45。
字符串：用引号括起来的内容（""、''、``）。

还有一个数组类型。它实际上是一个引用类型，所以如果 b 是数组并且执行了 "a=b"，那么 a 和 b 将引用同一个数组。
要创建数组的副本，请使用 ca 函数：dest = ca(source)。顺便说一句 - 你不能控制数组的维度 - 它们是自动调整大小的。
声明数组：
a = {};
声明数组并初始化某些项的值：
{"Hello!", "Use", "mixed types", 1.01e23, "like that", 1234};
访问数组：
a[index] = "Cool";

还可以将 [] 操作用于字符串。str[x] 返回一个字符串，其中仅包含索引为 x（从零开始）的单个字符。str[-x] 返回相同的结果，但 x 从字符串结尾计数（因此最后一个字符为 -1）。str[x,y] 返回范围为 x-y（包括 x 和 y）的字符，x 和 y 均可以为负数 - 在这种情况下，它们从字符串结尾计数。

一个有用的函数是将数组转换为字符串，然后再转回来。例如：
a = a("Hello"); str = s(a);
运行这样的脚本后，数组 a 将包含 6 个整数（字符和最后的零 - 字符串的结尾），而 str 将包含你的字符串。

运算符（一些是二元的，一些是一元的）：

= <<= -= += /= *= |= &= ^= %= -- ++ >> << && || <= =< >= => != ==
= + - * / % < > & | ^ ~ !
当然，并非所有运算符都适用于浮点数（逻辑和算术）和字符串（+ 和逻辑）。
额外的情况：引用/反引用运算符（& 和 *）。& 将给你一个参数的引用，该参数应该是一个变量（NSIS、用户、数组项、堆栈），而 * 将它转换回原始变量。例如 (a=&b; a=10) 将 b 设置为 10。表达式 (&a) 等同于简单的 (a)。

脚本是由用 ';' 分隔的表达式（一般是数学表达式）组成的集合。处理方式是数学上正确的（2+2*2 将得到 6），操作按 C 语言的顺序（优先级）执行。

流程控制：
if-then-else格式：#[if-expression, then-expr, else-expr]
示例：
#[a==0, b=1; c=2, b = (--c); c/=10]
C语言等价：
if (a==0) { b=1; c=2;} else { b=(c++);c-=10; }
while循环格式：#{expr, do}
示例：
#{(c<1.1e25)&&(b < 10), b++; c*=1.23}
C语言等价：
while ((c<1.1e25)&&(b<10)) { b++; c*=1.23; }

注意！逗号（,）用于分隔if-expr、then-expr和else-expr。由分号（;）分隔的所有子表达式都是一个表达式的一部分，最后一个子表达式的结果给出了表达式的结果。

所有的东西（如变量和函数）都将在调用之间保存。

函数：
类型转换：
l(string) 返回字符串或数组参数的长度
s(source) 将source转换为字符串类型
i(source) 将source转换为整数类型
f(source) 将source转换为浮点数类型
c(source) 如果source是字符串，则返回第一个字符的整数值；如果source是整数，则返回一个由单个字符（source）组成的字符串（带+0终止符）。
a(source) 将source转换为数组（仅支持字符串）
ff(float, format) 将浮点数转换为字符串，带有格式选项。
选项=精度+标志。
精度表示小数点后显示多少位。标志：
16（或0x10）- 不使用指数视图（数将显示为123.123）
32（或0x20）- 仅使用指数视图（数将显示为123.12e123）
64（或0x40）- 使用“E”字符而不是“e”
默认情况下，插件会自行决定如何显示您的数字。

math（所有这些函数的说明都可在 MSDN 上找到，使用给出的第二个名称进行搜索）：

单参数函数：
sin（x），sin，参数的正弦值
cos（x），cos，参数的余弦值
cel（x），ceil，参数的上限值（无小数部分）
csh（x），cosh，参数的双曲余弦值
exp（x），exp，指数
abs（x），abs，绝对值（警告：浮点数）
flr（x），floor，参数的下限值（无小数部分）
asn（x），asin，参数的反正弦值
acs（x），acos，参数的反余弦值
atn（x），atan，参数的反正切值
ln（x），log，指数对数
log（x），log10，十进制对数
snh（x），sinh，参数的双曲正弦值
sqt（x），sqrt，参数的平方根
tan（x），tan，参数的正切值
tnh（x），tanh，参数的双曲正切值

两个参数的函数：
at2（x，y），atan2，值（y / x）的反正切
pow（x，y），pow，幂，x ^ y
fmd（x，y），fmod，浮点数余数
fex（x，o），frexp，获取浮点数（x）的尾数（结果= r）和指数（o）：x = r *（2 ^ o）
mdf（x，o），modf，将浮点值拆分为小数和整数部分。

用户自定义函数。

非常简单，例如：
test(a,b) (a+b);
之后，test(1,2)将给出3。
test2(a,b) (a=a+b; b = a);
函数的结果总是最后一个表达式的结果。
如前所述，在函数调用之间最好不要使用堆栈（S）。
最好开发变量安全的函数，即不会破坏变量的函数。
为此，您应该将它们推入/弹出堆栈，或声明为永远不会使用的附加参数。例如：
test3(a,b,c) (c=10; #{--c > 0, a=sqrt(ab)}; a)
无论传递给函数的参数有多少个，所有三个变量（a、b、c）的值都将被保存。
这种变量安全的函数可以是递归的：

Math::Script 'rec(a) (#[a > 0, rec(a-1), 0]+a);'
Math::Script 'R1 = rec(10)'
将设置R1为正确的结果55。
有时函数需要返回多个值，在这种情况下，您可以将参数声明为引用（例如b）：
test4(a, &b) (b = aa; aaa)
在这种情况下，test4将返回a的3次方，如果我们像这样调用它test4(a,c)，
它将将a的2次方放置在c中。但是请注意：您应该在变量上使用解引用器（），
例如b。注意：永远不要将函数内部引用变量和外部参数变量（例如test4(a,b)）使用同一个变量。否则它肯定会失败。另外，如果您将参数声明为引用，您永远不应该向其提供常量表达式。它可以是数组项（array[1]）、NSIS寄存器R0、任何用户变量（除了具有相同名称的变量之外的变量），但永远不要使用常量。

另一个可能有用的可能性是重新声明函数（通常在函数已经定义的时候声明将简单地调用该函数）。对于这种任务，您可以使用“#name”，例如“func()(1);#func()(2);”。
但是请注意，函数声明发生在解析时，因此不可能执行流控制声明。
这是不可能的：“#[a<0,#func()(1),#func()(2)]”，它将简单地将#func定义为(2)，作为最新的变量。

（c）尼克·梅德韦德（brainsucker）
（翻译者注：后面部分段翻译存在一些问题，感觉上下文不连贯，读者可以结合原文理解）